

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  
  <title>快手C++开发一面 - gys的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"gys18007141407.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>gys的博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/miku6.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="快手C++开发一面">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-09-09 15:23" pubdate>
        2022年9月9日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      43
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">快手C++开发一面</h1>
	    <time updated datetime="2023-01-13 01:01"></time>
            
            <div class="markdown-body">
              <h3 id="1、四级页表"><a href="#1、四级页表" class="headerlink" title="1、四级页表"></a>1、四级页表</h3><ul>
<li>PGD: Page Global Directory (页目录)</li>
<li>PUD: Page Upper Directory (页目录)</li>
<li>PMD: Page Middle Directory (页目录)</li>
<li>PTE: Page Table Entry (页表项)</li>
</ul>
<h3 id="2、page-fault时机"><a href="#2、page-fault时机" class="headerlink" title="2、page fault时机"></a>2、page fault时机</h3><p>在Linux中，进程和内核都是通过页表PTE访问一个物理页面的，如果无法访问到正确的地址，将产生page fault（缺页异常）。由于造成内核空间和用户空间的page fault的原因不尽相同，因此其处理流程也有所区别（以x86为例，代码位于”/arch/x86/x86-mm/fault.c”）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __do_page_fault(...)<br>&#123;<br>    <span class="hljs-keyword">if</span> (unlikely(fault_in_kernel_space(address)))<br>        do_kern_addr_fault(regs, hw_error_code, address);<br>    <span class="hljs-keyword">else</span><br>        do_user_addr_fault(regs, hw_error_code, address);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，访问的内存地址必须是合法的，所谓「合法」，就是该地址一定是落在进程的某个VMA区间内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> <span class="hljs-title">vma</span> =</span> find_vma(mm, address);<br><br><span class="hljs-keyword">if</span> (unlikely(!vma)) &#123;<br>    bad_area(regs, hw_error_code, address);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (likely(vma-&gt;vm_start &lt;= address))<br>    <span class="hljs-keyword">goto</span> good_area;<br></code></pre></td></tr></table></figure>

<p>地址落在进程的地址空间内，但对地址的访问权限不对（比如试图写入一个readonly的区域），也是非法的。访问了非法的地址，或者非法地访问了地址，就不是page fault那么简单了，将进一步上升到segmentation fault。</p>
<p>如果地址合法，权限也正确，那么还得分两种情况来讨论。</p>
<p><strong>第一种情况</strong>是PTE不存在，这会出现在：</p>
<ul>
<li>对于anonymous page（匿名页），用户空间使用malloc()进行内存申请时（对应底层的实现是mmap或者brk），内核并不会立刻为其分配物理内存，而只是为请求的进程的rbtree管理的vma信息中记录（添加或更改）诸如内存范围和标志之类的信息。只有当内存被真正使用，触发page fault，才会真正分配物理页面和对应的页表项，即demand alloction，对应的函数实现是**do_anonymous_page()**。通过mmap映射建立的heap和stack等内存区域，在初始未使用时，也适用于这样的规则。</li>
</ul>
<ul>
<li>对于<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/68071761">page cache</a>（CPU如果要访问外部磁盘上的文件，需要首先将这些文件的内容拷贝到内存中，由于硬件的限制，从磁盘到内存的数据传输速度是很慢的，如果现在物理内存有空余，干嘛不用这些空闲内存来缓存一些磁盘的文件内容呢，这部分用作<strong>缓存磁盘文件</strong>的内存就叫做page cache）， 在发生内存回收后，部分text(code)段的页面会被discard，部分data段的页面会被writeback，之后再次访问这些页面，也将出现page fault。此时，需要从外部存储介质中，将页面内容调回内存，即demand paging，对应的函数实现是**do_fault()**。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">vm_fault_t</span> <span class="hljs-title">handle_pte_fault</span><span class="hljs-params">(struct vm_fault *vmf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!vmf-&gt;pte) &#123;<br>        <span class="hljs-keyword">if</span> (vma_is_anonymous(vmf-&gt;vma))<br>            <span class="hljs-keyword">return</span> do_anonymous_page(vmf);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> do_fault(vmf);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>第二种情况</strong>是PTE存在，但其中的”P(resent)”位为0，说明这是一个之前被swap out出去的anonymous page。现在PTE里存储的不是物理页面的编号PPN，而是外部swap area中slot的编号swp_entry_t，需要通过**do_swap_page()**，执行swap in操作将页面的内容拷贝回内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* orig_pte是指发生page fault时的PTE */</span><br><span class="hljs-keyword">if</span> (!pte_present(vmf-&gt;orig_pte))<br>    <span class="hljs-keyword">return</span> do_swap_page(vmf);<br></code></pre></td></tr></table></figure>

<p>发生page fault时，如果目标页面驻留在外部存储器，那么需要开销较大的I/O操作，这种page fault被称为”<strong>major</strong>“的。而如果目标页面就在内存中（比如<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/98793444">swap cache</a>），只是缺少一个对该页面的引用而已，这种page fault不需要重新分配内存页面，代价较小，因此被称为”<strong>minor</strong>“的。</p>
<p>还是那个<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/98793444">图书馆借书的例子</a>，前台相当于内存，书库相当于磁盘，从前台直接取走就是”minor page fault”，比如书到期了你还没有看完，可以在前台办完还书手续后马上再借（前提是这本书没有被其他读者预约），付出的代价就是多一次借书手续而已。</p>
<p>而如果你还了两个月再去借这本书，书已经被管理员上架了，你就需要自己去书架上按照类别寻找这本书，花费的时间自然较多，这就是”major page fault”。</p>
<h3 id="3、只要是非0地址那么用户态都可以使用吗"><a href="#3、只要是非0地址那么用户态都可以使用吗" class="headerlink" title="3、只要是非0地址那么用户态都可以使用吗"></a>3、只要是非0地址那么用户态都可以使用吗</h3><p>io空间、权限(只读段)</p>
<h3 id="4、共享内存是怎么实现的"><a href="#4、共享内存是怎么实现的" class="headerlink" title="4、共享内存是怎么实现的"></a>4、共享内存是怎么实现的</h3><p>进程页表转换到相同的物理地址</p>
<h3 id="5、实现一个内存池，保证每次调用分配内存的时候一定可用"><a href="#5、实现一个内存池，保证每次调用分配内存的时候一定可用" class="headerlink" title="5、实现一个内存池，保证每次调用分配内存的时候一定可用"></a>5、实现一个内存池，保证每次调用分配内存的时候一定可用</h3><h3 id="6、文件页和匿名页"><a href="#6、文件页和匿名页" class="headerlink" title="6、文件页和匿名页"></a>6、文件页和匿名页</h3><p>Linux中有后备文件支持的页称为文件页，如属于进程的代码段、数据段的页，内存回收的时候这些页面只需要做脏页的同步即可（干净的页面可以直接丢弃掉）。反之为匿名页，如进程的堆栈使用的页，内存回收的时候这些页面不能简单的丢弃掉，需要交换到交换分区或交换文件。</p>
<p>下面分析一个程序段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE (100*1024*1024)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 伪代码</span><br>	system(<span class="hljs-string">&quot;free -m&quot;</span>);<br>	<br>	<span class="hljs-comment">// 匿名映射: MAP_ANONYMOUS, fd=-1</span><br>	addr = mmap(<span class="hljs-literal">NULL</span>, SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>	system(<span class="hljs-string">&quot;free -m&quot;</span>);<br>	<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) val = addr[i];<br>	system(<span class="hljs-string">&quot;free -m&quot;</span>);<br>	<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) addr[i] = val;<br>	system(<span class="hljs-string">&quot;free -m&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一次提示执行free命令的时候，我们还没有开始通过mmap分配内存，此时free命令输出作为参考。</p>
<p>第二次提示执行free命令的时候，我们已经通过mmap分配了100M的内存，此时发现free命令输出内存消耗基本没有变化。</p>
<p>第三次提示执行free命令的时候，我们对于分配的匿名页面进行了读操作，此时发现free命令输出内存消耗页基本没有变化, <strong>这基本上会颠覆我们的认知</strong>。</p>
<p>第四次提示执行free命令的时候，我们对于分配的匿名页面进行了写操作，此时发现free命令输出内存消耗大概为100M。</p>
<h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><h5 id="1、mmap的内存消耗"><a href="#1、mmap的内存消耗" class="headerlink" title="1、mmap的内存消耗"></a>1、mmap的内存消耗</h5><p>mmap申请匿名页的时候，只是申请了虚拟内存（通过vm_area_struct结构来描述，如描述虚拟内存区域的地址范围、访问权限等，以下简称vma），实际的物理内存并没有申请（除了用于管理虚拟内存区域的vma等结构内存的申请），当前虚拟内存和物理内存并没有建立页表映射关系，而真正的申请的匿名页所对应的物理页在实际访问的时候按需分配获得，所以此时我们看不到内存的消耗情况。</p>
<h5 id="2、第一次读匿名页的内存消耗"><a href="#2、第一次读匿名页的内存消耗" class="headerlink" title="2、第一次读匿名页的内存消耗"></a>2、第一次读匿名页的内存消耗</h5><p>通过mmap申请完虚拟内存之后，进程就可以按照之前申请vma的访问权限进行访问，第一发生读访问，这个时候由于虚拟内存和物理内存并没有建立页表映射关系，通过虚拟地址并不能查找到物理内存，所以会发生处理器的异常，最终分析是因为数据访问异常导致，就由处理器架构相关的代码进入了我们通用的缺页异常处理例程中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;mm/memory.c&quot;</span><br><br>处理器架构相关异常处理代码<br>-&gt; handle_mm_fault<br>    -&gt; __handle_mm_fault<br>        -&gt; handle_pte_fault<br>            -&gt;  <span class="hljs-keyword">if</span> (!vmf-&gt;pte) &#123;   ------------------- <span class="hljs-number">1</span><br>                     <span class="hljs-keyword">if</span> (vma_is_anonymous(vmf-&gt;vma))  ------------------- <span class="hljs-number">2</span><br>                             <span class="hljs-keyword">return</span> do_anonymous_page(vmf);   ------------------- <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>缺页异常进入handle_pte_fault后，在1标签代码处，来判断访问的虚拟内存页的页表项是否为空，为空说明这个这个虚拟页没有和物理页建立映射关系。然后在2标签代码处判断是否为匿名页缺页异常（实际上是判断是否为私有的匿名页，当前当前示例代码场景申请的为私有匿名页面**即MAP_PRIVATE(创建CopyOnWrite的私有匿名页)**）。在3标签代码处，进行真正的私有匿名页缺页异常处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">do_anonymous_page<br>-&gt;pte_alloc(vma-&gt;vm_mm, vmf-&gt;pmd)   ------------------- <span class="hljs-number">1</span><br>-&gt;<span class="hljs-comment">/* Use the zero-page for reads */</span><br><span class="hljs-keyword">if</span> (!(vmf-&gt;flags &amp; FAULT_FLAG_WRITE) &amp;&amp;     ------------------- <span class="hljs-number">2</span><br>                !mm_forbids_zeropage(vma-&gt;vm_mm)) &#123; ------------------- <span class="hljs-number">3</span><br>        entry = pte_mkspecial(pfn_pte(my_zero_pfn(vmf-&gt;address),<br>                                        vma-&gt;vm_page_prot));  ------------------- <span class="hljs-number">4</span><br>        vmf-&gt;pte = pte_offset_map_lock(vma-&gt;vm_mm, vmf-&gt;pmd,<br>                        vmf-&gt;address, &amp;vmf-&gt;ptl);  ------------------- <span class="hljs-number">5</span><br>      <br>         ...<br>        <span class="hljs-keyword">goto</span> setpte;<br>&#125;<br>-&gt;  page = alloc_zeroed_user_highpage_movable(vma, vmf-&gt;address); ------------------- <span class="hljs-number">6</span><br>-&gt; entry = mk_pte(page, vma-&gt;vm_page_prot);  ------------------- <span class="hljs-number">7</span><br> entry = pte_sw_mkyoung(entry); ------------------- <span class="hljs-number">8</span><br> <span class="hljs-keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE)<br>         entry = pte_mkwrite(pte_mkdirty(entry));  ------------------- <span class="hljs-number">9</span><br><br> vmf-&gt;pte = pte_offset_map_lock(vma-&gt;vm_mm, vmf-&gt;pmd, vmf-&gt;address,<br>                 &amp;vmf-&gt;ptl); ------------------- <span class="hljs-number">10</span><br>                 <br> -&gt;set_pte_at(vma-&gt;vm_mm, vmf-&gt;address, vmf-&gt;pte, entry);  ------------------- <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure>

<p>1标签处：判断虚拟地址对应的pmd表项是否为空，为空来分配直接页表设置到pmd表项中。</p>
<p>2标签处：判断是否是进行读访问。</p>
<p>3标签处：判断是否没有禁止0页。</p>
<p>4标签处：就是对于没有禁止0页的匿名页读访问设置页表，这里通过0页的页帧号和mmap映射时指定的访问权限组合页表项的值。</p>
<p>5标签处：通过发生缺页的虚拟地址来计算出页表项的地址保存在 vmf-&gt;pte。</p>
<p>11标签处：将4标签初组合出的页表项的值写入到5标签初计算出的页表项中。</p>
<p>以上分析可知：<strong>对于私有的匿名页，第一次读访问的时候都会发生缺页异常，然后通过页表映射0页，这个0页没有什么特殊之处，只不过它是在系统启动过程中初始化好的一块内容全为0的页面，这样做可以为进程分配了内存只进行读访问节省大量物理内存。</strong></p>
<h5 id="3、第一次写匿名页的内存消耗"><a href="#3、第一次写匿名页的内存消耗" class="headerlink" title="3、第一次写匿名页的内存消耗"></a>3、第一次写匿名页的内存消耗</h5><p>大家可以将示例代码中，读访问屏蔽掉只进行写访问，观察内存消耗。</p>
<p>这个时候发生缺页异常时，不会在走2 3 4 5 便签处代码，而在6处分配了一个物理页面，在7 8 9组合页表项的值， 10处计算出页表项的地址，最后把组合的值设置到页表项中。</p>
<p>需要注意第9处，如果是<strong>写访问会设置页表项的可写标志位</strong>。</p>
<p>以上分析可知：对于私有的匿名页，第一次写访问的时候都会发生缺页异常，会真正分配一个物理页面，然后将虚拟页面通过页面映射到物理页面，所以我们能观察到写之后发生了大量内存消耗。</p>
<h5 id="4、第一次读然后写匿名页的内存消耗"><a href="#4、第一次读然后写匿名页的内存消耗" class="headerlink" title="4、第一次读然后写匿名页的内存消耗"></a>4、第一次读然后写匿名页的内存消耗</h5><p>这种场景就是示例代码中所做的实验，可以看到读的时候基本上没有内存消耗，写的时候发生了大量内存消耗。</p>
<p>关于第一次读，上面已经做过解释，下面主要看读完之后的页面发生写访问的情况。</p>
<p>实际上，对于一个私有的内存映射，在mmap的时候为页表映射准备访问权限的时候并不是给予所有的权限，而是<strong>把可写属性去掉</strong> 了。</p>
<p>我们可以从源代码找到答案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;mm/mmap.c&quot;</span><br><br>do_mmap<br>-&gt;mmap_region<br>    -&gt;vma_set_page_prot(vma)<br>        -&gt;vm_page_prot = vm_pgprot_modify(vma-&gt;vm_page_prot, vm_flags);  --------<span class="hljs-number">-1</span><br>            -&gt;pgprot_modify(oldprot, vm_get_page_prot(vm_flags))<br>        -&gt;WRITE_ONCE(vma-&gt;vm_page_prot, vm_page_prot);  --------------<span class="hljs-number">-2</span><br>        <br>        <br> <span class="hljs-comment">/* description of effects of mapping type and prot in current implementation.</span><br><span class="hljs-comment">  * this is due to the limited x86 page protection hardware.  The expected</span><br><span class="hljs-comment">  * behavior is in parens:</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * map_type     prot</span><br><span class="hljs-comment">  *              PROT_NONE       PROT_READ       PROT_WRITE      PROT_EXEC</span><br><span class="hljs-comment">  * MAP_SHARED   r: (no) no      r: (yes) yes    r: (no) yes     r: (no) yes</span><br><span class="hljs-comment">  *              w: (no) no      w: (no) no      w: (yes) yes    w: (no) no</span><br><span class="hljs-comment">  *              x: (no) no      x: (no) yes     x: (no) yes     x: (yes) yes</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * MAP_PRIVATE  r: (no) no      r: (yes) yes    r: (no) yes     r: (no) yes</span><br><span class="hljs-comment">  *              w: (no) no      w: (no) no      w: (copy) copy  w: (no) no</span><br><span class="hljs-comment">  *              x: (no) no      x: (no) yes     x: (no) yes     x: (yes) yes</span><br><span class="hljs-comment">  */</span><br>-&gt;vm_get_page_prot   <br>  <span class="hljs-keyword">pgprot_t</span> protection_map[<span class="hljs-number">16</span>] __ro_after_init = &#123;<br>        __P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,<br>        __S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>对于__Pxxx， 最后一个x表示vma属性是否可读，倒数第二个x表示vma属性是否可写，P后面的x表示是否可执行。</p>
<p>1标签处根据mmap传递的访问权限来构造最终的访问权限标识。</p>
<p>2标签处将构造好的访问权限标识记录到vma-&gt;vm_page_prot中，供缺页异常设置页表使用。</p>
<p>注释中已经做了详细的解释，具体页表属性如何表示由各自的处理器架构相关代码来做（eg: 对于x86架构 #define __P111 PAGE_COPY_EXEC），我们只需要知道：<strong>无论我们想让vma具备那些属性组合，都会屏蔽掉写属性</strong>，具体可以查看相关的处理器架构实现。</p>
<p>所以，再次回到缺页异常处理代码中。在2中的4标签处，使用mmap设置好的页表访问权限设置页表属性，当前场景我们知道，mmap中指定为私有的可读可写属性，而页表中只是<strong>设置为了只读属性</strong>。</p>
<p><strong>触发写时复制：</strong>读访问将虚拟页以只读的方式映射到了0页，当再次发生写操作时，就会再次触发数据访问异常，最终进入缺页异常处理例程中。</p>
<p>下面给出调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;mm/memory.c&quot;</span><br><br>handle_pte_fault<br>-&gt;<span class="hljs-keyword">if</span> (vmf-&gt;flags &amp; FAULT_FLAG_WRITE) &#123;  ----------<span class="hljs-number">-1</span><br>        <span class="hljs-keyword">if</span> (!pte_write(entry)) ----------<span class="hljs-number">-2</span><br>                <span class="hljs-keyword">return</span> do_wp_page(vmf); ----------<span class="hljs-number">-3</span><br></code></pre></td></tr></table></figure>

<p>可以看到最终也是在handle_pte_fault中处理：在1标签处判断是否为写访问。在2标签处判断页表项的属性是否是只读。在3标签处进行实际的写时复制处理。</p>
<p>以上分析可知：发生写访问操作时，如果vma可写，但是页表属性标识不可写（只读），会发生写时复制缺页异常，对于当前场景的0页的写访问就是如此，在do_wp_page中会重新分配物理页面映射到虚拟页面，然后页表设置为可写属性，就完成了缺页处理。</p>
<h5 id="总结：【懒惰原则】"><a href="#总结：【懒惰原则】" class="headerlink" title="总结：【懒惰原则】"></a>总结：【懒惰原则】</h5><p>1）mmap分配私有匿名内存时，会设置vma的vm_page_prot成员，去除掉页表的写访问标识。</p>
<p>2）第一次读匿名页时，对于可读可写的vma，虚拟页会以只读的方式映射到0页。</p>
<p>3）第一次写匿名页时，对于可读可写的vma，会申请物理页面，虚拟页以可读可写的方式映射到此物理页。</p>
<p>4）第一次读匿名页后，然后写匿名页，先只读方式映射到0页，然后发生写时复制，分配物理页，虚拟页以可读可写的方式映射到此物理页。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-info">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/11/BBR%E7%AE%97%E6%B3%95/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">BBR算法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/07/IEG%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF%E8%BF%90%E8%90%A5-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E4%BA%8C%E9%9D%A2/">
                        <span class="hidden-mobile">IEG游戏技术运营-后台开发二面</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
